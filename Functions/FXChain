--[[
Поскольку мы не можем редактировать непосредственно FXChain, а только в паре с чанком, пришлось заморочится. 
Итого, это 100% самая удобная схема.
Она позволяет легко оперировать FXChain и FX внутри FXChain как на одном треке, так и между треками.
То есть, в любых комбинациях и, что важно, без учета моментов взятия и установки чанка(если нужно), см. use_src_track_chunk.
В функции SetTrackFXChain(track, fx_chain, use_src_track_chunk):
если use_src_track_chunk = false - будет использован target track_chunk(текущий чанк трека на данный момент).
если use_src_track_chunk = true - будет использован source track_chunk(полученный на момент запуска GetChain).
Второй вариант быстрее, подходит для одномоментных операций, не растянутых во времени и только в рамках одного трека!
Выбирать по ситуации.
--]]

local FXChain = {}

---=============================================================================
function msg(m) reaper.ShowConsoleMsg("\n" .. tostring(m)) end
--------
function TimeTest(start_time, end_time, lbl)
  if (not start_time and end_time) then return end
  msg(lbl .. end_time - start_time .. "\n")
end

--==============================================================================
--------  Get-Set TrackChunk functions -----------------------------------------
--==============================================================================
--[[
== GetSet TrackChunk mini-description ============
In standart function GetTrackStateChunk chunk size limited 4194303 = 4094*1024-1 byte
На установку станд. ф-я вроде тянет более 4M, пока пробуем! Если будет косячить - вернуть WDL!
Хотя по тестам - на установке время одинаково...
Примечание по isundo:
isundo = false or isundo = true? See: https://forum.cockos.com/showthread.php?t=181000
Justin: If you use isundo=false, you will get your <PARMENVs  etc .... so disregard it and use false!
--]]
--------------------------------------------------
-- Get track chunk(allow > 4MB) ------------------
--------------------------------------------------
function GetTrackChunk(track)
  if not track then return end
  -- Try standart function -----
  local ret, track_chunk = reaper.GetTrackStateChunk(track, "", false) -- isundo = false
  if ret and track_chunk and #track_chunk < 4194303 then return track_chunk end
  -- If chunk_size >= max_size, use wdl fast string --
  local fast_str = reaper.SNM_CreateFastString("")
  if reaper.SNM_GetSetObjectState(track, fast_str, false, false) then
    track_chunk = reaper.SNM_GetFastString(fast_str)
  end
  reaper.SNM_DeleteFastString(fast_str)
  return track_chunk
end
--------------------------------------------------
-- Set track chunk(allow > 4MB) ------------------
--------------------------------------------------
function SetTrackChunk(track, track_chunk)
  if not (track and track_chunk) then return end
  return reaper.SetTrackStateChunk(track, track_chunk, false)
  --[[
  if #track_chunk < 4194303 then return reaper.SetTrackStateChunk(track, track_chunk, false) end  -- isundo = false
  -- If chunk_size >= max_size, use wdl fast string --
  local fast_str, ret 
  fast_str = reaper.SNM_CreateFastString("")
  if reaper.SNM_SetFastString(fast_str, track_chunk) then
    ret = reaper.SNM_GetSetObjectState(track, fast_str, true, false)
  end
  reaper.SNM_DeleteFastString(fast_str)
  return ret
  --]]
end

--==============================================================================
--------  GetSetTrackFXChain functions -----------------------------------------
--==============================================================================
--[[
== Get Chain mini-description ====================
Returned table description:
src_track_chunk - fx chain source track_chunk (исходный чанк)
_start - fx chain start position in track_chunk
_end   - fx chain end position in track_chunk
head - fx chain header content(часть от "<FXCHAIN..." до первого fx-чанка)
fxs[1] ... fxs[n] - fx chunks content, string, from "BYPASS.."  to "WAK .."
tail - fx chain tail content(часть от конца последнего fx-чанка до конца fx chain "...>\n")

== Set Chain mini-description ====================
Мы не можем установить FX chain отдельно от чанка трека, только совместно.
Поэтому, для повышения быстродействия применяем такой метод.
1)Используем booleen use_src_track_chunk = true:
Если мы уверены, что нам подходит исходный трек-чанк(в большинстве ситуаций это так), то оставляем его.
2)Используем booleen use_src_track_chunk = false:
Если необходимо влепить FX chain в другой чанк(на другой трек, или текущий трек успел измениться) - берем по-новой.
--]]

--------------------------------------------------
-- Get FX Chain if chain empty or no exist -------
--------------------------------------------------
function FXChain.GetEmpty(track_chunk)
  local _start, _end, head, tail, fxs, s, e, t
  --------
  s, e = track_chunk:find("MAINSEND.-\n") -- firstly, find "MAINSEND" string
  _start, _end, head = track_chunk:find("^(<FXCHAIN\n.-)>\n", e + 1) -- Try find empty FXCHAIN
  --------
  if not _start then -- if empty FXCHAIN not found, use custom values
    _start, _end = e + 1, e -- its correct values for inserting, see FXChain.Set
    head = "<FXCHAIN\nWNDRECT 100 100 100 100\nSHOW 0\nLASTSEL 0\nDOCKED 0\n" 
  end
  --------
  if not _start then return end
  local t = {src_track_chunk = track_chunk, _start = _start, _end = _end, head = head, tail = ">\n", fxs = {} }
  return t
end
--------------------------------------------------
-- Get FX Chain, return table see description  ---
--------------------------------------------------
function FXChain.Get(track)
  if not track then return end
  local track_chunk = GetTrackChunk(track) -- Get Track Chunk
  if not track_chunk then return end
  --------
  local fx_cnt = reaper.TrackFX_GetCount(track)
  if fx_cnt == 0 then return FXChain.GetEmpty(track_chunk) end
  --------
  local _start, _end, head, tail, fxs, s, e, fx_chunk 
  _start, e, head = track_chunk:find("(<FXCHAIN\n.-)BYPASS") -- start, head
  --------
  fxs = {}
  e = e - 6 -- sub "BYPASS" length
  for i = 1, fx_cnt do -- get fx_chunks
    s, e, fx_chunk = track_chunk:find("^(BYPASS %d %d %d\n.-WAK %d\n)", e + 1)
    if fx_chunk then fxs[i] = fx_chunk else return end
  end
  --------
  local s, _end, tail = track_chunk:find("(.->\n)", e + 1) -- end, tail
  --------
  local t = {src_track_chunk = track_chunk, _start = _start, _end = _end, head = head, tail = tail, fxs = fxs} 
  return t
end
--------------------------------------------------
-- Set FX Chain, return true if succefully  ------
--------------------------------------------------
function FXChain.Set(track, fx_chain, use_src_track_chunk)
  if not (track and fx_chain) then return end
  --------
  local cur_fx_chain
  if use_src_track_chunk then cur_fx_chain = fx_chain else cur_fx_chain = FXChain.Get(track) end
  if not cur_fx_chain then return end
  --------
  local s, e, track_chunk = cur_fx_chain._start - 1, cur_fx_chain._end + 1, cur_fx_chain.src_track_chunk
  --------
  track_chunk = track_chunk:sub(1, s) .. fx_chain.head .. table.concat(fx_chain.fxs) .. fx_chain.tail .. track_chunk:sub(e)
  --------
  return SetTrackChunk(track, track_chunk)
end

--==============================================================================
--------  Modify FXChain functions ---------------------------------------------
--==============================================================================
--[[
== Modify FXChain mini-description ===============
Эти функции являются простейшими операциями с таблицами.
Многое сюда может быть добавлено и упростит задачи в дальнейшем.
По идее, их можно было не писать, а действовать конкретно по ситуации, но так гораздо удобнее.
Все операции с чанками должны быть безошибочными - в таком виде легче тестировать и ловить косяки.
БУДЕТ СОВСЕМ ЗАДАЛБЫВАТЬ ИМЕНАМИ - СТАВИТЬ i, j + хороший комментарий, все!!!
----
NOTE: idx for ALL functions 1-based(it's Lua!) !!!!!!!
--]]

--------------------------------------------------
-- Move fx = src_idx to new position = dest_idx ---
function FXChain.MoveFX(fx_chain, src_idx, dest_idx)
  local tmp = fx_chain.fxs[src_idx] 
  table.remove(fx_chain.fxs, src_idx)
  table.insert(fx_chain.fxs, dest_idx, tmp)
end
--------------------------------------------------
-- Remove fxs from first_idx to last_idx inclusive
--[[
Если last_idx не указан, last_idx = first_idx.
Если first_idx не указан, first_idx = #fx_chain.fxs(последний в цепи).
Если last_idx указан, first_idx должен быть указан.
На практике - FXChain.RemoveFX(fx_chain) - удаляет последний FX.
FXChain.RemoveFX(fx_chain, first_idx) - удаляет один FX - first_idx.
Это удобно, принцип примерно как в ф-ях Lua.
--]] 
function FXChain.RemoveFX(fx_chain, first_idx, last_idx)
  first_idx = first_idx or #fx_chain.fxs
  last_idx = last_idx or first_idx
  for i = first_idx, last_idx do
    table.remove(fx_chain.fxs, first_idx)
  end
end
--------------------------------------------------
-- Exchange fxs idx1 <> idx2(меняет местами) -----
function FXChain.ExchangeFX(fx_chain, idx1, idx2)
  fx_chain.fxs[idx1], fx_chain.fxs[idx2] = 
  fx_chain.fxs[idx2], fx_chain.fxs[idx1]
end

--================================================
-- Insert fx(from fx_chunk) to pos = idx ---------
function FXChain.InsertFXFromChunk(fx_chain, fx_chunk, idx)
  table.insert(fx_chain.fxs, idx, fx_chunk)
end

--================================================
-- Get fx(fx_chunk), return fx_chunk  ------------
function FXChain.GetFXChunk(fx_chain, idx)
  return fx_chain.fxs[idx]
end
--================================================
-- Set fx_chunk(from fx_chunk) -------------------
function FXChain.SetFXChunk(fx_chain, fx_chunk, idx)
  fx_chain.fxs[idx] = fx_chunk
end



--==============================================================================
return FXChain



